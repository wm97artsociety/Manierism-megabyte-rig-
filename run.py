#!/usr/bin/env python3

import os
import time
import json
import random
import uuid
from decimal import Decimal, getcontext
import hashlib # Added for symbolic SHA256 use

# High precision
getcontext().prec = 200

# --- Paths & constants ---
BASEDIR = "/storage/emulated/0/Download/manierismmegabytes"
TARGETDIR = os.path.join(BASEDIR, "rigs")
os.makedirs(TARGETDIR, exist_ok=True)

# --- YOUR LOCAL WALLET IDs ---
DONATION_WALLET_ID = "WM-CPH0O7J3" 
WORLD_DEBT_WALLET_ID = "WD-P4Y29G7B"
# ---------------------------

# --- World Debt Constants ---
WORLD_DEBT_NODE_ID = "9efae649-eb1f-4ef0-ac97-ed4df6d2942f" 
INITIAL_WORLD_DEBT_USD = Decimal("31300000000000.00") 
WORLD_DEBT_DATE = "October 4th, 2025" 
# This value dictates how much USD is passively generated by the World Debt Node
DEBT_NODE_PASSIVE_USD_VALUE = Decimal("0.0001") 
# ---------------------------------

BASE_HASH_POWER = Decimal("10000") 
HASH_GROWTH_RATE = Decimal("0.001")
PRE_GAME_HALVING_MULTIPLIER = Decimal("79000")

# --- DEBUG SETTING ---
DEBUG_SHA_BOOST = True
# ---------------------

# --- USD BACKING RATES ---
MB_USD_RATE = Decimal("5.00")
CACHE_USD_RATE = Decimal("0.42")
KWH_USD_RATE = Decimal("0.17")
BANDWIDTH_USD_RATE = Decimal("0.42")
# -------------------------------------

# -----------------------------------------------------------
# --- NEW HASH FORMULA IMPLEMENTATION ---
# -----------------------------------------------------------

# Symbolic constants for the hash formula
TEPI2 = "TEPI2_CONSTANT"
E2PI = "E2PI_CONSTANT"
BLOCK_HEADER = "MM_BLOCK_HEADER_2025"

def vh_btc_hash_function(capsule_header, amp_capsule):
    """
    Symbolic implementation of the VH_BTC hash formula.
    VH_BTC = SHA256(CapsuleHeader || SHA256(BlockHeader) || Amp_capsule || TEPI2 || E2PI)
    In this simulation, the output is a simple string for representation.
    """
    # Simulate SHA256(BlockHeader)
    sha_block = hashlib.sha256(BLOCK_HEADER.encode()).hexdigest()
    
    # Concatenate all components symbolically
    pre_image = f"{capsule_header}{sha_block}{amp_capsule}{TEPI2}{E2PI}"
    
    # Simulate final hash result
    final_hash = hashlib.sha256(pre_image.encode()).hexdigest()
    
    return final_hash

def calculate_rig_hash_power(wallet):
    """
    The rig's Hash Power (H/s) is now a function of its resources and permanent gains.
    It serves as the Amp_capsule in the hash formula.
    Hashpower = (Base_Hash_Power + Gains) * (1 + Resource_Bonus)
    """
    # Permanent Hash Power from donations, SHA boosts, and passive growth
    permanent_hash_power = wallet["rig_hash_power"]
    
    # Add a resource bonus based on Cache MB (as Cache MB has the special multiplier)
    # The resource bonus ensures that owning resources directly boosts the *rate* of hashing.
    resource_bonus = wallet.get('cache_value_mb', Decimal('0')) / Decimal('1000') 
    
    # The actual Hash Power used for mining rate (Amp_capsule)
    effective_hash_power = permanent_hash_power * (Decimal('1') + resource_bonus)
    
    return effective_hash_power.quantize(Decimal('0.000001'))

# -----------------------------------------------------------
# --- END NEW HASH FORMULA IMPLEMENTATION ---
# -----------------------------------------------------------


# --- Node Utility ---
def generate_node_id():
    """Generates a unique ID for a network node."""
    return str(uuid.uuid4())

# --- Wallet Utilities ---
def save_wallet(wallet):
    wallet_copy = wallet.copy()
    # Remove the temporary flags before saving
    wallet_copy.pop("sha_boost_active", None)
    for key, value in wallet_copy.items():
        if isinstance(value, Decimal):
            wallet_copy[key] = float(value)
    wallet_file = os.path.join(TARGETDIR, f"{wallet['wallet_id']}_wallet.json")
    with open(wallet_file, "w") as f:
        json.dump(wallet_copy, f, indent=4)

def _ensure_wallet_has_node(data):
    # Special handling for World Debt wallet to ENFORCE the specified Node ID
    if data.get('wallet_id') == WORLD_DEBT_WALLET_ID:
        if data.get("node_id") != WORLD_DEBT_NODE_ID:
            data["node_id"] = WORLD_DEBT_NODE_ID
            
    # Regular node ID assignment
    elif "node_id" not in data or not data["node_id"]:
        data["node_id"] = generate_node_id()
        
    return data

def load_wallet(wallet_id):
    wallet_file = os.path.join(TARGETDIR, f"{wallet_id}_wallet.json")
    if not os.path.exists(wallet_file):
        return None
    with open(wallet_file, "r") as f:
        data = json.load(f)
        
    # Ensure all fields are present as Decimal for arithmetic consistency
    if "world_debt_paid_usd" not in data:
        data["world_debt_paid_usd"] = 0.0
        
    for key in ["capsule_value_mb", "cache_value_mb", "rig_hash_power", "real_kwh", "bandwidth_MBps", "world_debt_paid_usd"]:
        if key in data:
            data[key] = Decimal(str(data[key]))
            
    # Add temporary SHA boost state to wallet object, not saved to file
    data["sha_boost_active"] = False
    
    original_node_id = data.get("node_id")
    data = _ensure_wallet_has_node(data)
    
    # If node ID was fixed for WD wallet, save the update
    if data.get('wallet_id') == WORLD_DEBT_WALLET_ID and data.get("node_id") == WORLD_DEBT_NODE_ID and original_node_id != WORLD_DEBT_NODE_ID:
         save_wallet(data)
         
    return data

def create_wallet(wallet_id, rig_id=None):
    existing = load_wallet(wallet_id)
    if existing:
        return existing
    
    # Preventing manual creation of special wallets
    if wallet_id in [DONATION_WALLET_ID, WORLD_DEBT_WALLET_ID]:
        display_id = rig_id if rig_id else wallet_id
        print(f"üõë Error: Wallet ID '{display_id}' is reserved for special system purposes and cannot be created here.")
        return None
        
    node_id = generate_node_id()
    
    wallet = {
        "wallet_id": wallet_id,
        "rig_id": rig_id or wallet_id,
        "capsule_value_mb": Decimal("0"),
        "cache_value_mb": Decimal("0"),
        "rig_hash_power": BASE_HASH_POWER,
        "real_kwh": Decimal("0"),
        "bandwidth_MBps": Decimal("0"),
        "node_id": node_id,
        "world_debt_paid_usd": Decimal("0"), 
    }
    save_wallet(wallet)
    return wallet

# --- Isolated Special Wallet Initialization ---
def _initialize_special_wallets():
    """Initializes the special, local-only donation and World Debt wallets only if their files are missing."""
    
    # 1. Initialize the Donation Wallet (WM-CPH0O7J3)
    if not load_wallet(DONATION_WALLET_ID):
        print(f"üõ†Ô∏è Initializing Donation Wallet: {DONATION_WALLET_ID}")
        wallet = {
            "wallet_id": DONATION_WALLET_ID,
            "rig_id": "donations",
            "capsule_value_mb": Decimal("0"),
            "cache_value_mb": Decimal("0"),
            "rig_hash_power": BASE_HASH_POWER,
            "real_kwh": Decimal("0"),
            "bandwidth_MBps": Decimal("0"),
            "node_id": generate_node_id(), 
            "world_debt_paid_usd": Decimal("0"), 
        }
        save_wallet(wallet)
    
    # 2. Initialize the World Debt Wallet (WD-P4Y29G7B)
    if not load_wallet(WORLD_DEBT_WALLET_ID):
        print(f"üõ†Ô∏è Initializing World Debt Wallet: {WORLD_DEBT_WALLET_ID}")
        wallet = {
            "wallet_id": WORLD_DEBT_WALLET_ID,
            "rig_id": "world debt fund", 
            "capsule_value_mb": Decimal("0"),
            "cache_value_mb": Decimal("0"),
            "rig_hash_power": BASE_HASH_POWER,
            "real_kwh": Decimal("0"),
            "bandwidth_MBps": Decimal("0"),
            "node_id": WORLD_DEBT_NODE_ID, 
            "world_debt_paid_usd": Decimal("0"), 
        }
        save_wallet(wallet)
# --- END Isolated Special Wallet Initialization ---

# --- World Debt Node Passive Value Generation ---
def world_debt_node_value_generation():
    """Adds a small, passive USD value to the World Debt fund (stored as Capsule MB)."""
    debt_wallet = load_wallet(WORLD_DEBT_WALLET_ID)
    if not debt_wallet:
        return

    if debt_wallet.get('node_id') != WORLD_DEBT_NODE_ID:
        return
        
    mb_generated = DEBT_NODE_PASSIVE_USD_VALUE / MB_USD_RATE
    debt_wallet['capsule_value_mb'] += mb_generated
    save_wallet(debt_wallet)
# --- END World Debt Node Passive Value Generation ---

def calculate_total_usd(wallet):
    """Calculates the total USD-backed value of all resources in a wallet."""
    return (
        wallet.get('capsule_value_mb', Decimal("0")) * MB_USD_RATE +
        wallet.get('cache_value_mb', Decimal("0")) * CACHE_USD_RATE +
        wallet.get('real_kwh', Decimal("0")) * KWH_USD_RATE +
        wallet.get('bandwidth_MBps', Decimal("0")) * BANDWIDTH_USD_RATE
    )

# --- World Debt Payment Functions ---
def show_world_debt_payment_menu(wallet):
    while True:
        debt_wallet = load_wallet(WORLD_DEBT_WALLET_ID)
        if not debt_wallet:
            print("‚ö†Ô∏è World Debt Wallet not found. Check local files.")
            break
            
        # The total paid is the total USD value of all assets in the debt wallet
        total_debt_paid_usd = calculate_total_usd(debt_wallet) 
        remaining_debt = INITIAL_WORLD_DEBT_USD - total_debt_paid_usd
        
        if remaining_debt < 0:
            remaining_debt = Decimal("0")
        
        print("\n--- üåé World Debt Payment Plan ---")
        print(f"üìä Global Debt Snapshot (As of {WORLD_DEBT_DATE}):")
        print("-" * 40)
        print(f"  Total Starting Debt: ${INITIAL_WORLD_DEBT_USD:,.2f}")
        print(f"  Total Debt Paid:     ${total_debt_paid_usd:,.2f} (from all sources)")
        print(f"  Remaining Debt:      ${remaining_debt:,.2f}")
        print("-" * 40)
        print(f"üí∞ Your Total Contribution: ${wallet['world_debt_paid_usd']:,.2f}")
        print(f"üíµ Your Current Watts USD Balance: ${calculate_total_usd(wallet):,.2f}")
        print("-" * 40)
        print("1. Send Watts USD to Pay World Debt")
        print("2. Back to Wallet Actions")
        
        option = input("Enter option: ").strip()
        
        if option == "1":
            contribute_to_world_debt(wallet)
        elif option == "2":
            break
        else:
            print("‚ö†Ô∏è Invalid option.")

def contribute_to_world_debt(wallet):
    try:
        debt_wallet = load_wallet(WORLD_DEBT_WALLET_ID)
        if not debt_wallet:
             print("‚ö†Ô∏è World Debt Wallet not found. Aborting contribution.")
             return
             
        amt = Decimal(input("Amount of Watts USD to contribute: ").strip())
        if amt <= 0:
            print("‚ö†Ô∏è Enter a positive amount.")
            return

        total_usd = calculate_total_usd(wallet)
        if amt > total_usd:
            print(f"‚ö†Ô∏è Not enough Watts USD-backed balance. Max: ${total_usd:,.2f}")
            return

        # 1. Deduct proportional resources from sender
        proportion = amt / total_usd
        # Ensure we don't try to deduct more than the current balance (should be protected by amt > total_usd check, but safe to clamp)
        wallet['capsule_value_mb'] -= wallet['capsule_value_mb'] * proportion
        wallet['cache_value_mb'] -= wallet['cache_value_mb'] * proportion
        wallet['real_kwh'] -= wallet['real_kwh'] * proportion
        wallet['bandwidth_MBps'] -= wallet['bandwidth_MBps'] * proportion

        # 2. Convert USD contribution to the highest value resource (Capsule MB) for the debt wallet
        mb_equivalent = amt / MB_USD_RATE
        debt_wallet['capsule_value_mb'] += mb_equivalent

        # 3. Track personal contribution
        wallet['world_debt_paid_usd'] += amt

        save_wallet(wallet)
        save_wallet(debt_wallet)
        print(f"‚úÖ Contributed ${amt:,.2f} Watts USD to the World Debt Fund.")
    except Exception as e:
        print(f"‚ùå Error: {e}")
        
# --- END World Debt Payment Functions ---

# --- Device cache scan ---
def scan_device_cache_mb(delete_after=False):
    """Simplified placeholder for scanning device cache."""
    # This simplified version just returns a placeholder to prevent errors
    return Decimal("0"), [] 


# --- Mining ---
CUSTOM_REWARDS = [
    "2piE", "TE", "TE2pi", "Manierism", "Handrichism",
    "RAM", "SDRAM", "SHA", "Nuclear", "Onshore",
    "Gigabyte", "Terabyte", "Petabyte", "PIB", "Electrism"
]

def unified_mining_loop(wallet, mining_type):
    TOTAL_YEARS = 75
    MAX_TICKS = TOTAL_YEARS * 365
    current_tick = 0

    try:
        while current_tick < MAX_TICKS:
            wallet = load_wallet(wallet['wallet_id'])
            if not wallet:
                print("‚ö†Ô∏è Wallet disappeared. Stopping mining.")
                break
            
            # Apply passive World Debt gain (runs on every tick)
            world_debt_node_value_generation()

            capsule_type = random.choice(CUSTOM_REWARDS)
            if DEBUG_SHA_BOOST and current_tick == 0 and mining_type == "sha":
                capsule_type = "SHA"

            # --- NEW HASH POWER CALCULATION (VH_BTC Amp_capsule) ---
            effective_hash_power = calculate_rig_hash_power(wallet)
            sha_boost_amount_added = Decimal("0")
            
            # Symbolic Execution of the Hash Formula
            vh_hash = vh_btc_hash_function(capsule_type, str(effective_hash_power))
            
            # --- PERMANENT SHA BOOST LOGIC ---
            if mining_type == "sha" and capsule_type == "SHA":
                # 1. Calculate the boost amount (1/4 of current permanent power)
                boost_amount = wallet["rig_hash_power"] / Decimal("4")
                
                # 2. MAKE THE BOOST PERMANENT
                wallet["rig_hash_power"] += boost_amount
                
                # 3. Update the temporary variable for calculation/display
                sha_boost_amount_added = boost_amount
                
                # 4. Set active flag and notify user
                wallet["sha_boost_active"] = True
                print(f"üå† SHA Boost PERMANENTLY +{boost_amount:.6f} H/s to Wallet: {wallet['wallet_id']}")
            # --- END PERMANENT SHA BOOST LOGIC ---

            # --- REWARD CALCULATION IS NOW BASED ON EFFECTIVE HASH POWER ---
            scaling_factor = effective_hash_power / BASE_HASH_POWER
            base_mb_reward_roll = Decimal(random.randint(1, 15))
            
            # Apply the pre-game multiplier
            reward_mb = base_mb_reward_roll * scaling_factor * PRE_GAME_HALVING_MULTIPLIER
            reward_kwh = reward_mb
            base_bandwidth_roll = Decimal(random.randint(1, 15))
            reward_bandwidth = base_bandwidth_roll * scaling_factor * PRE_GAME_HALVING_MULTIPLIER
            
            # Passive Hash Power Growth (Uses permanent H/s, not the effective/resource-boosted H/s)
            reward_hash_gain = wallet["rig_hash_power"] * HASH_GROWTH_RATE 

            rewarded_resource = "Capsule MB"
            if mining_type == "cache":
                # Cache mining rewards both Cache and Capsule MB
                wallet["cache_value_mb"] += reward_mb
                wallet["capsule_value_mb"] += reward_mb
                rewarded_resource = "Cache & Capsule MB"
            else:
                wallet["capsule_value_mb"] += reward_mb

            # Permanent H/s growth from passive gain is added here.
            wallet["rig_hash_power"] += reward_hash_gain 
            wallet["real_kwh"] += reward_kwh
            wallet["bandwidth_MBps"] += reward_bandwidth
            wallet["sha_boost_active"] = False
            save_wallet(wallet)

            # Display the new, higher permanent value (which includes the SHA boost if it occurred)
            display_permanent_hash_power = wallet["rig_hash_power"] 

            # --- PRINT REWARDS INCLUDING USD VALUE ---
            total_usd = calculate_total_usd(wallet)

            print(f"\n--- Capsule Mined: {capsule_type} ({mining_type.upper()}) ---")
            print(f"Hash Found (VH_BTC): {vh_hash[:10]}...")
            print(f"üíµ {rewarded_resource} Gained: {reward_mb:,.6f}")
            print(f"‚ö° kWh Gained:     {reward_kwh:,.6f}")
            print(f"üõ∞Ô∏è Bandwidth Gained: {reward_bandwidth:,.6f} MB/s")
            print(f"--------------------------")
            print(f"üìà H/s Gain:       {reward_hash_gain:.6f} (Passive)")
            print(f"üå† H/s (Effective):{effective_hash_power:.6f} (Includes Resource Bonus)")
            print(f"üå† H/s (Permanent):{display_permanent_hash_power:.6f}")
            print(f"SHA Boost:        {sha_boost_amount_added:.6f} (ADDED PERMANENTLY)")
            print(f"Balance MB:       {wallet['capsule_value_mb']:,.6f}")
            print(f"Balance Cache MB: {wallet['cache_value_mb']:,.6f}")
            print(f"üí∞ Total USD Value (Watts-backed): ${total_usd:,.2f}") 

            current_tick += 1
            time.sleep(random.randint(5, 150)) 

        print(f"\n‚úÖ Mining complete after reaching {TOTAL_YEARS} years.")

    except KeyboardInterrupt:
        print("\n‚õî Mining stopped by user.")


# --- Send and Donate Functions ---
# (send_resource and donate_for_hash are kept from the second file as they contain the necessary logic)

def send_resource(wallet, resource_name):
    try:
        target_id = input(f"Enter target Wallet ID to send {resource_name.replace('_',' ')}: ").strip()
        
        if target_id in [DONATION_WALLET_ID, WORLD_DEBT_WALLET_ID]:
            print("üõë Cannot send resources to these reserved wallet IDs using the general send function. Use the Donation or Debt menu.")
            return

        amt = Decimal(input("Amount to send: ").strip())
        if amt <= 0:
            print("‚ö†Ô∏è Enter a positive amount.")
            return

        if resource_name == "usd_value":
            total_usd = calculate_total_usd(wallet)
            if amt > total_usd:
                print(f"‚ö†Ô∏è Not enough USD-backed balance. Max: ${total_usd:,.2f}")
                return
            proportion = amt / total_usd
            wallet['capsule_value_mb'] -= wallet['capsule_value_mb'] * proportion
            wallet['cache_value_mb'] -= wallet['cache_value_mb'] * proportion
            wallet['real_kwh'] -= wallet['real_kwh'] * proportion
            wallet['bandwidth_MBps'] -= wallet['bandwidth_MBps'] * proportion

        else:
            if wallet.get(resource_name, Decimal("0")) < amt:
                print(f"‚ö†Ô∏è Not enough {resource_name.replace('_',' ')} balance.")
                return
            wallet[resource_name] -= amt

        target = load_wallet(target_id) or create_wallet(target_id)
        if not target: 
            return
            
        if resource_name == "usd_value":
            # Target wallet absorbs the USD value by proportional increase
            total_usd_target = calculate_total_usd(target)
            if total_usd_target > 0:
                factor = (total_usd_target + amt) / total_usd_target 
                target['capsule_value_mb'] *= factor
                target['cache_value_mb'] *= factor
                target['real_kwh'] *= factor
                target['bandwidth_MBps'] *= factor
            else:
                # If target has zero assets, give it the highest value asset equivalent
                target['capsule_value_mb'] += amt / MB_USD_RATE
            
        else:
            target[resource_name] = target.get(resource_name, Decimal("0")) + amt

        save_wallet(wallet)
        save_wallet(target)
        print(f"‚úÖ Sent {amt} {'Watts USD' if resource_name == 'usd_value' else resource_name.replace('_',' ')} from {wallet['wallet_id']} to {target_id}")
    except Exception as e:
        print(f"‚ùå Error: {e}")

def donate_for_hash(wallet, resource_name):
    donation_wallet = load_wallet(DONATION_WALLET_ID)
    if not donation_wallet:
        print("‚ö†Ô∏è Donation wallet not found.")
        return
    try:
        amt = Decimal(input(f"Amount {resource_name.replace('_',' ')} to donate: ").strip())
        if amt <= 0:
            print("‚ö†Ô∏è Enter a positive amount.")
            return

        if wallet.get(resource_name, Decimal("0")) < amt:
            print(f"‚ö†Ô∏è Not enough {resource_name.replace('_',' ')} balance.")
            return

        wallet[resource_name] -= amt
        donation_wallet[resource_name] = donation_wallet.get(resource_name, Decimal("0")) + amt

        hash_power_gain = amt
        if resource_name == "cache_value_mb":
            # Special multiplier for Cache MB donation
            hash_power_gain *= PRE_GAME_HALVING_MULTIPLIER
            print(f"‚ú® Applied {PRE_GAME_HALVING_MULTIPLIER}x amplifier to Hash Power gain for Cache MB donation.")

        wallet["rig_hash_power"] += hash_power_gain

        save_wallet(wallet)
        save_wallet(donation_wallet)
        print(f"üôè Donated {amt} {resource_name.replace('_',' ')}.")
        print(f"üöÄ Gained {hash_power_gain:.6f} Hash Power!")
    except Exception as e:
        print(f"‚ùå Error: {e}")

# --- Utility Functions for Wallet Selection ---
def _get_all_wallets():
    """Helper to return a dictionary of all loaded wallets {id: wallet_object}"""
    files = [f for f in os.listdir(TARGETDIR) if f.endswith("_wallet.json")]
    wallets_data = {}
    for f in files:
        wallet_id = f.replace("_wallet.json", "")
        wallets_data[wallet_id] = load_wallet(wallet_id)
    return wallets_data

def select_wallet_or_rig():
    wallets_data = _get_all_wallets()
    if not wallets_data:
        print("‚ö†Ô∏è No wallets/rigs found.")
        return None
        
    print("\nSelect a Rig/Wallet or type Wallet ID:")
    
    # Sort for consistent display order, putting system wallets last
    sorted_wallet_ids = sorted(wallets_data.keys(), key=lambda x: (x != WORLD_DEBT_WALLET_ID, x != DONATION_WALLET_ID, x))

    for i, wallet_id in enumerate(sorted_wallet_ids, 1):
        rig_id = wallets_data[wallet_id].get('rig_id', wallet_id)
        print(f"{i}. {rig_id} ({wallet_id})") 
        
    choice = input("Enter number or Wallet ID: ").strip()
    
    if choice.isdigit():
        idx = int(choice)
        if 1 <= idx <= len(sorted_wallet_ids):
            wallet_id = sorted_wallet_ids[idx-1]
            return wallets_data.get(wallet_id)
        
    return wallets_data.get(choice) 

def select_wallet_for_mining():
    wallets_data = _get_all_wallets()
    
    # Filter out system wallets
    user_wallets_ids = [id for id in wallets_data.keys() if id not in [DONATION_WALLET_ID, WORLD_DEBT_WALLET_ID]]
    
    if not user_wallets_ids:
        print("‚ö†Ô∏è No personal wallets/rigs found. Create one first (Option 5).")
        return None
        
    print("\n--- Select Rig for Mining ---")
    
    sorted_user_wallets = sorted(user_wallets_ids)

    for i, wallet_id in enumerate(sorted_user_wallets, 1):
        rig_id = wallets_data[wallet_id].get('rig_id', wallet_id)
        print(f"{i}. {rig_id} ({wallet_id})")
        
    choice = input("Enter number: ").strip()
    
    if choice.isdigit():
        idx = int(choice)
        if 1 <= idx <= len(sorted_user_wallets):
            wallet_id = sorted_user_wallets[idx-1]
            return wallets_data.get(wallet_id)
    
    print("‚ö†Ô∏è Invalid selection.")
    return None

# --- Dashboard & Rig Info ---

def show_rig_dashboard(wallet):
    # Ensure to load the latest state for special wallets
    if wallet['wallet_id'] in [WORLD_DEBT_WALLET_ID, DONATION_WALLET_ID]:
        wallet = load_wallet(wallet['wallet_id'])

    device_cache, _ = scan_device_cache_mb() 
    total_usd = calculate_total_usd(wallet)
    effective_hash_power = calculate_rig_hash_power(wallet) # Use the new formula

    print(f"\n--- Capsule Rig Dashboard ‚Äî {wallet['rig_id']} ---")
    print(f"Wallet ID: {wallet['wallet_id']}")
    print(f"üåê Node ID: {wallet.get('node_id','N/A')[:8]}...")
    print(f"üå† Hash Power (Permanent): {wallet['rig_hash_power']:.6f}")
    print(f"üöÄ Hash Power (Effective): {effective_hash_power:.6f} (Used for Mining Rate)") 
    if wallet.get("sha_boost_active"):
        boost_calc = wallet['rig_hash_power'] / Decimal('4') 
        print(f"‚ö° SHA Boost ACTIVE: +{boost_calc:.6f} H/s ") 
    print(f"üíæ Capsule MB: {wallet['capsule_value_mb']:,.6f}")
    print(f"üì¶ Cache MB: {wallet['cache_value_mb']:,.6f}")
    print(f"üì• Device Cache (User Folders): {device_cache:.6f} MB")
    print(f"‚ö° Real kWh: {wallet['real_kwh']:,.6f}")
    print(f"üì° Bandwidth: {wallet['bandwidth_MBps']:,.6f} MB/s")
    print(f"üíµ WATTS USD Value: ${total_usd:,.2f}")
    print("-" * 40)
    
    if wallet['wallet_id'] == WORLD_DEBT_WALLET_ID:
         total_debt_paid_usd = calculate_total_usd(wallet) 
         print(f"üåé Total Debt Paid: ${total_debt_paid_usd:,.2f} (This Wallet's USD Value)") 
    elif wallet['wallet_id'] != DONATION_WALLET_ID:
        print(f"üåé World Debt Contributed: ${wallet['world_debt_paid_usd']:,.2f}") 

    print("-" * 40)

def show_rig_download_info(wallet):
    wallet_file_path = os.path.join(TARGETDIR, f"{wallet['wallet_id']}_wallet.json")
    
    print("\n--- üíæ Everything About the Rig: Download & Location Info ---")
    print(f"üöÄ Rig/Wallet ID:   {wallet['rig_id']} / {wallet['wallet_id']}")
    print(f"üåê Node ID:         {wallet.get('node_id', 'N/A')}")
    print("-" * 55)
    print("üìú Rig Configuration File Location:")
    print(f"Path: {wallet_file_path}")
    
    try:
        file_size_kb = os.path.getsize(wallet_file_path) / 1024
        print(f"Size: {file_size_kb:.2f} KB (Current State)")
    except OSError:
        print("Size: File not accessible (Check permissions/existence)")

    print("-" * 55)
    print("üì¶ Base Download Directory (Manierism Megabytes):")
    print(f"Path: {BASEDIR}")
    print("-" * 55)
    print("üí° Download Instructions:")
    print("To **transfer** your rig, you must copy the entire 'manierismmegabytes' folder.")
    print("-" * 55)
    input("Press Enter to continue...")

def show_receive_info(wallet):
    print("\n--- Receive Info ---")
    print(f"Wallet ID (for receiving resources): {wallet['wallet_id']}")
    print(f"Node ID (for network interactions): {wallet['node_id']}")
    print("Share these to receive transfers.")
    input("Press Enter to continue...")

def download_resource_menu(wallet):
    print("\n--- Download Resource to File ---")
    print("1. Capsule MB (.bin)")
    print("2. Cache MB (.bin)")
    print("3. kWh (.json)")
    print("4. Bandwidth (.json)")
    option = input("Select resource type to download: ").strip()

    resource_map = {
        "1": ("capsule_value_mb", "bin", "MB"),
        "2": ("cache_value_mb", "bin", "MB"),
        "3": ("real_kwh", "json", "kWh"),
        "4": ("bandwidth_MBps", "json", "MB/s")
    }

    if option not in resource_map:
        print("‚ö†Ô∏è Invalid option.")
        return

    resource_name, ext, unit_name = resource_map[option]
    current_value = wallet.get(resource_name, Decimal("0"))

    print(f"Available {resource_name.replace('_',' ')}: {current_value:,.6f} {unit_name}")

    amt = Decimal(input(f"Enter amount to download (min 1 {unit_name}): ").strip())

    if amt < 1 or amt > current_value:
        print(f"‚ö†Ô∏è Invalid amount. Please enter a value between 1 and {current_value:,.6f} {unit_name}.")
        return

    file_name = input("Enter file name (without extension): ").strip()
    full_path = os.path.join(BASEDIR, f"{file_name}.{ext}")

    # Deduct from wallet
    wallet[resource_name] -= amt
    save_wallet(wallet)

    # Create file
    try:
        if ext == "bin":
            # MB files are handled as binary data (approximate size)
            with open(full_path, "wb") as f:
                # Use min to prevent creating a huge file if amt is massive (safe limit of 1GB)
                write_size = min(int(amt * 1024 * 1024), 1024 * 1024 * 1024) 
                f.write(os.urandom(write_size)) 
        else:
            # kWh and Bandwidth files are handled as JSON data
            with open(full_path, "w") as f:
                json.dump({resource_name: float(amt)}, f, indent=4)

        print(f"‚úÖ Downloaded {amt} {resource_name.replace('_',' ')} to {full_path}")
    except Exception as e:
        print(f"‚ùå Failed to download: {e}")
        
# --- Wallet Transactions & Donations (Updated for 14 Options) ---
def wallet_transaction_menu(wallet):
    while True:
        wallet = load_wallet(wallet['wallet_id'])
        if not wallet:
            break

        show_rig_dashboard(wallet)
        print("\n--- Wallet Actions ---")
        print("1. Send Capsule MB")
        print("2. Send Cache MB")
        print("3. Send kWh")
        print("4. Send Bandwidth")
        print("5. Send Watts USD")
        print("-" * 40)
        print("6. Donate Capsule MB to Creator (Gain Hash Power)")
        print("7. Donate Cache MB to Creator (Gain Hash Power)")
        print("8. Donate kWh to Creator (Gain Hash Power)")
        print("9. Donate Bandwidth to Creator (Gain Hash Power)")
        print("-" * 40)
        print("10. View Receive Info (Wallet/Node IDs)")
        print("11. Download Resource to File")
        print("12. Everything About the Rig (Download Info)")
        print("13. World Debt Payment Plan üåé")
        print("14. Back to Main Menu")
        print("-" * 40)
        option = input("Enter option: ").strip()

        if option == "1":
            send_resource(wallet, "capsule_value_mb")
        elif option == "2":
            send_resource(wallet, "cache_value_mb")
        elif option == "3":
            send_resource(wallet, "real_kwh")
        elif option == "4":
            send_resource(wallet, "bandwidth_MBps")
        elif option == "5":
            send_resource(wallet, "usd_value")
        elif option == "6":
            donate_for_hash(wallet, "capsule_value_mb")
        elif option == "7":
            donate_for_hash(wallet, "cache_value_mb")
        elif option == "8":
            donate_for_hash(wallet, "real_kwh")
        elif option == "9":
            donate_for_hash(wallet, "bandwidth_MBps")
        elif option == "10":
            show_receive_info(wallet)
        elif option == "11":
            download_resource_menu(wallet)
        elif option == "12":
            show_rig_download_info(wallet)
        elif option == "13":
            # Only allow payment from non-system wallets
            if wallet['wallet_id'] in [DONATION_WALLET_ID, WORLD_DEBT_WALLET_ID]:
                print("üõë Cannot access the World Debt Payment Plan menu from a system wallet.")
            else:
                show_world_debt_payment_menu(wallet)
        elif option == "14":
            break
        else:
            print("‚ö†Ô∏è Invalid option.")


def start_mining(mining_type):
    wallet = select_wallet_for_mining()
    if wallet:
        print(f"Starting {mining_type.upper()} Mining for wallet {wallet['wallet_id']}...")
        unified_mining_loop(wallet, mining_type)


def view_wallets_rigs_menu():
    wallet = select_wallet_or_rig()
    if wallet:
        wallet_transaction_menu(wallet)


# --- Main Menu ---
def main_menu():
    
    _initialize_special_wallets()
    # Run once at startup to initialize passive gain logic
    world_debt_node_value_generation() 

    while True:
        print("\n=== Manierism Megabytes Mining Menu ===")
        print("1. Start CPU Mining (Select Rig)")
        print("2. Start Wi-Fi Mining (Select Rig)")
        print("3. Start SHA Capsule Mining (Select Rig)")
        print("4. Start Cache Mining (Select Rig)")
        print("5. Create New Rig / Wallet")
        print("6. View Wallets & Rigs / Wallet Actions")
        print("7. Exit")
        choice = input("Enter option (1-7): ").strip()
        
        # Run on every menu interaction to keep the passive World Debt updated
        world_debt_node_value_generation() 

        if choice == "1":
            start_mining("cpu")
        elif choice == "2":
            start_mining("wifi")
        elif choice == "3":
            start_mining("sha")
        elif choice == "4":
            start_mining("cache")
        elif choice == "5":
            rig_id = input("Enter Rig ID or Wallet Name: ").strip()
            wallet_id = input("Enter Wallet ID: ").strip()
            new_wallet = create_wallet(wallet_id, rig_id)
            if new_wallet:
                print(f"‚úÖ Created new wallet/rig: {rig_id} ({wallet_id}) with Node ID: {new_wallet['node_id']}")
        elif choice == "6":
            view_wallets_rigs_menu()
        elif choice == "7":
            print("Exiting... üëãSee you later F&F‚ù§Ô∏è")
            break
        else:
            print("‚ö†Ô∏è Invalid selection.")


# --- Run Application ---
if __name__ == "__main__":
    main_menu()
